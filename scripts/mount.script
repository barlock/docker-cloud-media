#!/bin/bash
###############################################################################
# mount.remote - A script to mount GDrive remote for use with Plex
###############################################################################
# CONFIGURATION
###############################################################################
# shellcheck source=config

. "/usr/bin/variables"

declare -a rclone_mount_options=(
  --config /config/rclone.conf
  # Very verbose for debugging
  -vv
  # Mount on top of non-empty directory
  --allow-non-empty
  # This is for allowing users other than the user running rclone access to the mount
  --allow-other
  # Google Drive is a polling remote so this value can be set very high and any changes are detected via polling.
  --dir-cache-time 1000h
  # I reduce the poll interval down to 15 seconds as this makes changes appear fast. the API quotas per day are huge
  --poll-interval 15s
  # This is setting the file permission on the mount to user and group have the same access and other can read
  --umask 002
  # Please set this to your own value below
  --user-agent fleet
  # The local disk used for caching
  --cache-dir /cache
  # This is used for caching files to local disk for streaming
  --vfs-cache-mode full
  # This limits the cache size to the value below
  --vfs-cache-max-size 800G
  # This adds a little buffer for read ahead
  --vfs-read-ahead 256M
  # This limits the age in the cache if the size is reached and it removes the oldest files first
  --vfs-cache-max-age 1000h
  # This sets a per file bandwidth control and I limit this to a little bigger than my largest bitrate I'd want to play
  --bwlimit-file 16M
)
###############################################################################
# FUNCTIONS
###############################################################################
mount_gdrive () {
	# Make sure GD mountpoint exists.
	if [ ! -d "${cloud_encrypt_dir}" ]; then
		mkdir -p "${cloud_encrypt_dir}"
	fi

	# Mount GD if not already mounted.
	if [ $(ps -ef | grep "rclone" | grep -v "grep" | wc -l) == "0" ]; then
		echo "[ $(date $(printenv DATE_FORMAT)) ] Mounting Google Drive mountpoint: ${cloud_encrypt_dir}"
		rclone mount "${rclone_mount_options[@]}" "$(printenv CLOUD_ENDPOINT)" "${cloud_encrypt_dir}" &
	else
		echo "[ $(date $(printenv DATE_FORMAT)) ] Google Drive mountpoint: ${cloud_encrypt_dir} already mounted."
	fi
}

mount_decrypt_gdrive () {
	# Make sure decrypted GD directory exists.
	if [ ! -d "${cloud_decrypt_dir}" ]; then
		mkdir -p "${cloud_decrypt_dir}"
	fi

	sleep 5
	while [ -z "$(ls -A ${cloud_encrypt_dir})" ]
	do
		echo "Waiting for mount ${cloud_encrypt_dir} ..."
		sleep 30
	done

	if [ $(ps -ef | grep "encfs --extpass=" | grep -v "grep" | wc -l) == "0" ]; then
		echo "[ $(date $(printenv DATE_FORMAT)) ] Mounting decrypted Google Drive: ${cloud_decrypt_dir}"
		ENCFS6_CONFIG=/config/encfs6.xml encfs --extpass="echo ${ENCFS_PASSWORD}" $encfs_mount_options "${cloud_encrypt_dir}" "${cloud_decrypt_dir}" &
	else
		echo "[ $(date $(printenv DATE_FORMAT)) ] Decrypted mountpoint: ${cloud_decrypt_dir} already mounted."
	fi
}

mount_encrypt_local () {
    # Make sure combined plex media directory exists.
	if [ ! -d "${local_encrypt_dir}" ]; then
		mkdir -p "${local_encrypt_dir}"
	fi

	if [ $(ps -ef | grep "encfs --reverse" | grep -v "grep" | wc -l) == "0" ]; then
		echo "[ $(date $(printenv DATE_FORMAT)) ] Mounting encrypted local Drive: ${local_encrypt_dir}"
		ENCFS6_config=/config/encfs6.xml encfs --reverse --extpass="echo ${ENCFS_PASSWORD}" $encfs_mount_options "${local_media_dir}" "${local_encrypt_dir}" &
	else
		echo "[ $(date $(printenv DATE_FORMAT)) ] Encrypted mountpoint: ${local_encrypt_dir} already mounted."
	fi
}

mount_union () {
	# Make sure combined plex media directory exists.
	if [ ! -d "${local_union_dir}" ]; then
		mkdir -p "${local_union_dir}"
	fi

	sleep 5
	while [ -z "$(ls -A ${cloud_decrypt_dir})" ]
	do
		echo "Waiting for mount ${cloud_decrypt_dir} ..."
		sleep 30
	done


	# Mount plex media directory if not already mounted.
	if [ $(ps -ef | grep "unionfs" | grep -v "grep" | wc -l) == "0" ]; then
		ufs_mounts="${local_media_dir}=RW:${cloud_decrypt_dir}=RO"

		echo "[ $(date $(printenv DATE_FORMAT)) ] Mounting union: ${local_union_dir}"
		unionfs $ufs_options "${ufs_mounts}" "${local_union_dir}"
	else
		echo "[ $(date $(printenv DATE_FORMAT)) ] Union mountpoint: ${local_union_dir} already mounted."
	fi
}

###############################################################################

if pidof -o %PPID -x "$(basename "$0")"; then
	echo "[ $(date $(printenv DATE_FORMAT)) ] Mount already in progress. Aborting."
else
    if [ "$(printenv LOCAL_DRIVE)" != "0" ]; then
        mount_encrypt_local
    fi

    if [ "$(printenv REMOTE_DRIVE)" != "0" ]; then
        if [ "$(printenv REMOTE_PROVIDED)" == "0" ]; then
            mount_gdrive
        fi

        mount_decrypt_gdrive
    fi

    if [ "$(printenv LOCAL_DRIVE)" != "0" ] && [ "$(printenv REMOTE_DRIVE)" != "0" ]; then
        mount_union
    fi
fi

exit 0
